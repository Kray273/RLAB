v <- 5
w <- 10
v + w
v + w
print("Hello, R!!!") # ctrl+Enter
print("Hello, R!!!") # ctrl+Enter
print("Hello, R!!!") # ctrl+Enter
print("Hello, R!!!") # ctrl+Enter
print("Hello, R!!!") # ctrl+Enter
print("Hello, R!!!") # ctrl+Enter
print("Hello, R!!!") # ctrl+Enter
print("Hello, R!!!") # ctrl+Enter
print("Hello, R!!!") # ctrl+Enter
print("Hello, R!!!") # ctrl+Enter
print("Hello, R!!!") # ctrl+Enter
print("Hello, R!!!") # ctrl+Enter
print("Hello, R!!!") # ctrl+Enter
# R package 보기
dim(available.packages())
#op = [1] 18688    17 dim은 차원의 갯수를 알려주는 매서드로 R에서 제공하는 package의 수를 알려줌.
# R을 잘한다는 의미는 Rd에서 제공하는 패키지를 얼마나 잘 알고 활용하는지로 판단 할 수 있다.
# 패키지의 목록을 보고 싶다면 다음과 같은 매서드르 실시
available.packages()
# 패키지 사용법
install.packages("stringr") # 패키지를 사용하기 위해서는 먼저 설치를 해줘야한다.
library("stringr") #메모리에 로딩 : "" 생략 가능!
search() # 패키지 메모리 로딩을 확인
library("stringr")
#메모리에 로딩 : "" 생략 가능!
search()
#패키지 제거
remove.packages("stringr")
search()
# R session보기
sessionInfo()
# R session보기
sessionInfo()
# 데이터 셋 보기
data()
# 기본 데이터 셋으로 히스토그램 그리기(시각화)
# 단계 1 : 빈도수(frequency)를 기준으로 히스토그램 그리기
hist(Nile)
(N
# 기본 데이터 셋으로 히스토그램 그리기(시각화)
# 단계 1 : 빈도수(frequency)를 기준으로 히스토그램 그리기
hist(Nile)
# 기본 데이터 셋으로 히스토그램 그리기
# 단계1 : 빈도수(frequency)를 기준으로 히스토그램 그리기
hist(Nile)
#단계 2 : 밀도(density)를 기준으로 히스토그램 그리기
hist(Nile, freq = F)
#단계 2 : 밀도(density)를 기준으로 히스토그램 그리기
hist(Nile, freq = F)
# 기본 데이터 셋으로 히스토그램 그리기
# 단계1 : 빈도수(frequency)를 기준으로 히스토그램 그리기
hist(Nile)
#단계 2 : 밀도(density)를 기준으로 히스토그램 그리기
hist(Nile, freq = F)
# 기본 데이터 셋으로 히스토그램 그리기
# 단계1 : 빈도수(frequency)를 기준으로 히스토그램 그리기
hist(Nile)
#단계 2 : 밀도(density)를 기준으로 히스토그램 그리기
hist(Nile, freq = F)
# op : 사진 2
# 자바의 오버로딩과 같은 개념으로 같은 매서드여도 변수의 개수가 달라 사용할 수 있다.
# 엄밀히 말하면 작동원리는 오버로딩의 개념이 아니다.
# F = FALSE 인데 R은 대소문자를 구분하고, 부울린의 값은 대문자만 정의됨. 약자를 지원함(TRUE = T).
# 자바와 달리 변수의 순서가 달라져도 상관없다.
# 그 이유는
?hist
#단계 3 : 단계2의 결과에 분포곡선(line)을 추가.
lines(density(Nile))
par(mfrow = c(1, 1)) # plots 영역에 1개의 그래프 표시
# c라는 함수는 combine의 약자로 첫번째와 두번째 지정된 매개변수에 1을 전달한다.
# mflow에 c가 리턴한 값을 받아 전달 받는다.
# par은 히스토그램을 출력해달라는 의미이다.
pdf("C:/workspaces/RLAB/src/Day62/output/batch.pdf") # /가 폴더 변경
hist(rnorm(20)) #정규분포를 따르는 랜덤한 값 20개 발생
dev.off()
## 4. 변수와 자료형
# 변수 사용 예
age <- 25
age
age
age <- 35
age
## 4. 변수와 자료형
# 변수 사용 예
age <- 25
age
## 4. 변수와 자료형
# 변수 사용 예
age <- 25
age
age <- 35
age
# 스칼라 변수 사용 예
name <- "홍길동"
name
var1 <- 50
var2 <- 100
# 자료형
int <- 20    # 숫자형(정수)
double <- 3.14 # 숫자형(실수)
string <- "홍길동"  # 문자형
boolean <- TRUE  # 진리값 : TRUE(T) / FALSE(F)
boolean
boolean <- 3.14
boolean
goods.model <- "lg-320" #상품 모델명
goods.model <- "lg-320" #상품 모델명
goods.name <- "냉장고"
goods.price <- 850000
goods.desc <- "동금 최고 품질/사양"
# 자료형 확인
?boolean
# 자료형 확인
??boolean
# 자료형 확인
is.numeric(int)
# 자료형 확인
is.numeric(name) #자료형이 숫자인지 확인 T/F로 결과값반환
is.integer(age)
is.double(int) #
as.integer(int) #as는 형변환
as.integer(int) #as는 형변환
# 자료형
int <- 20    # 숫자형(정수)
castInt <- as.integer(int) #as는 형변환
is.integer(castInt)
is.numeric(double)
is.double(double)
is.character(string)
is.character(age) #T
is.character("double")
# 문자 원소를 숫자 원소로 형변환(두개 이상의 값이 있으면 백터자료)
x <- c(1, 2, 3)
x
# 숫자 원소를 문자 원소로 형변환
y <- c(1, 2, "3")
y
# op -> "1" "2" "3"
# c는 서로 다른 자료형은 저장할 수 없다. 숫자와 문자형에 관해서 자동 캐스팅.
# R뿐만이 아닌 다른 프로그럼 언어들도 동일
result <- x * 3
result
result <- y * 5
result <- as.integer(y) * 5
result
# 복소수형 자료 생성과 형변환
z <- 5.3 - 3i
Re(z)
Im(z)
# op -> [1] -3
is.complex(z) # TRUE
as.complex(5.3) # 5.3+0i
# 스칼라 변수의 자료형
mode(int)
mode(string)
mode(boolean)
boolean <- TRUE  # 진리값 : TRUE(T) / FALSE(F)
# op -> [1] "character"
mode(boolean)
# 문자 벡터와 그래프 생성
gender <- c('man', 'woman', 'woman', 'man', 'man')
gender
mode(gender)
class(gender)
plot(gender)
plot(gender)
# 요인형 변환
# as.factor() 함수 이용 범주(요인)형 변환
Ngender <- as.factor(gender)
Ngender
# op ->
# [1] man   woman woman man   man
# Levels: man woman
table(Ngender)
# Factor형 변수로 차트 그리기
plot(Ngender)
# op -> 사진 4-1S
mode(Ngender)
# op -> [1] "numeric"
class(Ngender)
is.factor(Ngender)
# Factor Nominal 변수
Ngender
# factor() 함수 이용 Factor형 변환
args(factor)
Ogender <- factor(gender,levels = c('wonan','man'),
labels = c("여자","남자"), ordered = T)
Ogender
Ogender <- factor(gender,levels = c('woman','man'),
labels = c("여자","남자"), ordered = T)
Ogender
# 순서 없는 요인과 순서 있는 요인형 변수로 차트 그리기
par(mfrow=c(1,2))
plot(Ngender)
plot(Ogender)
# 도움말 보기
i <- sum(1, 2, 3)
i
help(sum)
# 함수 파라메터 보기
args(sum)
# 함수 사용 예제 보기
example(sum)
# 작업 공간 지정
getwd()
setwd(C:/workspaces/RLAB/data)
setwd(C:/workspaces/RLAB/data)
setwd(C:\workspaces/RLAB/data)
setwd(C:/workspaces/RLAB/data) #작업 위치 지정
# 작업 공간 지정
getwd() #작업 공간 확인
# 작업 공간 지정
getwd() #작업 공간 확인
setwd(C:/workspaces/RLAB/data) #작업 위치 지정
setwd("C:/workspaces/RLAB/data") #작업 위치 지정
# 작업 공간 지정
getwd() #작업 공간 확인
# 1. Vector 자료 구조
##  - C() 함수 이용 벡터 객체 생성
x <- c(1, 2, 3, 4, 5) # combine 함수
x
x <- c(1:20) # 콜론 : 범위
x
y <- 10:20
y
##  - seq() 함수 이용 벡터 객체 생성
x <- seq(1, 10, 2) #sequence()
x
##  - rep() 함수 이용 벡터 객체 생성
help(rep) # ?rep
example(rep)
rep(1:3, 3)
# op -> 1 2 3 1 2 3 1 2 3
rep(1:3, each=3)
# union(), setdiff(), intersect() 함수 이용
x <- c(1, 3, 5, 7)
y <- c(3, 5)
x; y
union(x, y)     # 합집합(x+y)
union(x, y)     # 합집합(x+y)
# op ->
setdiff(x, y)   # 차집합(x-y)
# op ->
intersect(x, y) # 교집합(x^y)
# 숫자형, 문자형, 논리형 벡터 생성
v1 <- c(33, -5, 20:23, 12, -2:3)
v1
# op ->
v2 <- c(33, -5, 20:23, 12, "4") # 데이터를 모두 문자형으로 변환.
v2
# 한 줄에 명령문 중복 사용
v1; mode(v1)
# 한 줄에 명령문 중복 사용
v1; mode(v2) #mode  : 자료형을 반환
# 벡터에 컬럼명 지정
age <- c(30,35,40)
age
# op -> [1] 30 35 40
names(age) <- c("홍길동","이순신","강감찬")
age
# op ->
# 홍길동 이순신 강감찬
# 30     35     40
age <- NULL # 초기화!!
age
# op ->
# 홍길동 이순신 강감찬
# 30     35     40
age <-NULL # 초기화!!
age
# 벡터 자료 참조하기
a <- c(1:50)
a
# op ->
# [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34
# [35] 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
a[10] # Java와 다르게 index가 1 부터 가운트
# op -> [1] 10
a[c(10:15)]
# op -> [1] 10 11 12 13 14 15
a[c(10,20,30,40)]
# op ->
a[10:(length(a)-5)]
# op ->
a[10:(length(a)-30)]
# 잘못된 벡터 첨자 사용 예
a[5,10]
# c() 함수에서 콤마 사용 예
v1 <- c(33, -5, 20:23, 12, -2:3)
v1
# op -> [1] 33 -5 20 21 22 23 12 -2 -1  0  1  2  3
v1[1]
# op -> [1] 33
v1[c(2,6)]
# op -> [1] -5 23
v1[3:5]
# op -> [1] 20 21 22
v1[c(1,3:5,8]
# op -> [1] 20 21 22
v1[c(1,3:5,8)]
# 음수 값으로 첨자 지정 예
v1[-1]
# op -> [1] -5 20 21 22 23 12 -2 -1  0  1  2  3
v1[-5]
# op -> [1] -5 20 21 22 23 12 -2 -1  0  1  2  3
v1[-2]
# op -> [1] 33 20 21 22 23 12 -2 -1  0  1  2  3
v1[-c(2:6)]
# 패키지 설치와 메모리 로딩
install.packages("RSADBE") # 패키지(데이터) 설치
library(RSADBE)            # 패키지를 메모리에 로드
data("Severity_Counts")    # RSADBE 패키지에서 제공되는 데이터 셋 가져오기.
View(fred)
str(Severity_Counts)
# 벡터 이용 행렬 객체 생성
m <- matrix(c(1:5))
m  # 5행 1열
# 패키지에서 제공되는 벡터데이터 셋 보기
Severity_Counts
# 2. Matrix 자료 구조
args(matrix)
m <- matrix(c(1:10), nrow = 2) # 2행 5열
m
# 행과 열의 수가 일치하지 않는 경우 예
m <- matrix(c(1:11), nrow = 2)
# 행과 열의 수가 일치하지 않는 경우 예
m <- matrix(c(1:11), nrow = 2)
# op ->
# Warning message:
#   In matrix(c(1:11), nrow = 2) :
#   data length [11] is not a sub-multiple or multiple of the number of rows [2]
m
# 벡터의 행 우선으로 행렬 객체 생성
m <- matrix(c(1:11), nrow = 2, byrow = T)
# 벡터의 행 우선으로 행렬 객체 생성
m <- matrix(c(1:10), nrow = 2, byrow = T)
m
m <- matrix(c(1:10),  byrow = T)
m
m <- matrix(c(1:10),  ncol = 10)
m
# 행 묶음으로 행렬 객체 생성
x1 <- c(5,40,50:52)
x2 <- c(30, 5, 6:8)
mr <- rbind(x1,x2)
mr
# 열 묶음으로 행렬 객체 생성
mc <- cbind(x1,x2)
mc
# 2행으로 행렬 객체 생성
m3 <- matrix(c(10:19),nrow = 2)
m3
# 자료와 객체 type 보기
mode(m3); class(m3) # numeric, matrix
# 행렬 객체에 첨자로 접근
# java의 경우 int[][] num = new int[2][5];로 설정하고
# num[1][2] = 15;로 값을 넣음.
m3[2,3]
# op -> [1] 15
m3[1,]
# op -> [1] 10 12 14 16 18
m3[,5]
# op -> [1] 18 19
m3[1,c(2:5)] # 1행에서 2~5열 데이터
# op -> [1] 18 19
m3[1,c(2:4)] # 1행에서 2~4열 데이터
# op -> [1] 12 14 16
m3[1,c(2,4)] # 1행에서 2,4열 데이터
# 3차원 배열 객체 자료 조회
x <- matrix(c(1:9),nrow = 3, ncol = 3)
x
x <- matrix(c(1:9),nr = 3, nc = 3)
x
# 자료의 개수 보기
length(x) # 데이터 개수
ncol(x); nrow(x) # 열 / 행 수
# apply() 함수 적용
apply(x, 1, max) #두번쨰 매개변수는 1은 행, 2은 열을 의미
# apply() 함수 적용
apply(x, 1, max) #두번쨰 매개변수는 1은 행, 2은 열을 의미
# op -> [1] 7 8 9
apply(x, 1, min)
# op -> [1] 1 2 3
apply(x, 2, mean) # 열 단위의 평균값값
