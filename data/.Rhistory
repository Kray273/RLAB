xyplot(Ozone ~ Wind | factor(Month), data = airquality, layout=c(5, 1)) # factor(Month) : 범주값으로 출력.
# airquality 데이터셋의 Month 타입 변경(factor)
convert <- transform(airquality, Month=factor(Month))
str(convert)  # $ Month : Factor w/ 5 levels "5","6","7","8",..:
head(convert)
xyplot(Ozone ~ Wind | Month, data = convert, layout=c(5, 1))
# quakes 데이터 셋으로 산점도 그래프 그리기
head(quakes)
str(quakes)  # 'data.frame':	1000 obs. of  5 variables:
range(quakes$stations) # 10~132(관측소)
View(quakes)
# 지진 발생 위치(위도와 경도)
xyplot(lat~long, data=quakes, pch="o")
# 그래프를 변수에 저장
tplot <- xyplot(lat~long, data=quakes, pch=".")
# 그래프에 제목 추가
tplot2 <- update(tplot, main="1964년 이후 태평양에서 발생한 지진위치")
tplot2
# 산점도 그래프 그리기
# 1. depth 이산형 변수 범위 확인.
range(quakes$depth) # 40~680 : depth 범위
# 2. depth 변수 리코딩:6개의 범주(100단위)로 코딩 변경.
quakes$depth2[quakes$depth >= 40 & quakes$depth <= 150] <- 1
quakes$depth2[quakes$depth >= 151 & quakes$depth <= 250] <- 2
quakes$depth2[quakes$depth >= 251 & quakes$depth <= 350] <- 3
quakes$depth2[quakes$depth >= 351 & quakes$depth <= 450] <- 4
quakes$depth2[quakes$depth >= 451 & quakes$depth <= 550] <- 5
quakes$depth2[quakes$depth >= 551 & quakes$depth <= 680] <- 6
View(quakes)
# 3. 리코딩 변수(depth2)를 조건으로 산점도 그래프 그리기
convert <- transform(quakes, depth2 = factor(depth2))
xyplot(lat~long | depth2, data=convert)
# 동일한 패널에 2개의 y축에 값을 표현.
xyplot(Ozone+Solar.R ~ Wind | factor(Month),
data = airquality,
col=c("blue", "red"),
layout=c(5,1))
# (1) 1~150을 대상으로 겹쳐치지 않게 4개 영역으로 범주화
numgroup <- equal.count(1:150, number=4, overlap=0)
numgroup
# (2) 지진의 깊이를 5개 영역으로 범주화
depthgroup <- equal.count(quakes$depth, number=5, overlap=0)
depthgroup
# 범주화된 변수(depthgroup)를 조건으로 산점도 그래프 그리기
xyplot(lat~long | depthgroup, data = quakes,
main="Fiji Earthquakes(depthgroup)",
ylab="위도", xlab="경도",pch="@", col="red")
# 수심과 리히터규모 변수를 동시에 적용하여 산점도 그래프 그리기
magnitudegroup <- equal.count(quakes$mag, number=2, overlap=0)
magnitudegroup
# magnitudegroup 변수 기준으로 플로팅
xyplot(lat~long | magnitudegroup, data = quakes,
main="Fiji Earthquakes(magnitude)",
ylab = "latitude", xlab = "longitude",
pch="@", col="blue")
# 수심과 리히터 규모를 동시에 표현(2행 5열 패널 구조)
xyplot(lat~long | depthgroup*magnitudegroup, data=quakes,
main="Fiji Earthquakes",
ylab = "latitude", xlab = "longitude",
pch="@", col=c("red", "blue"))
# depth 변수 리코딩분
quakes$depth3[quakes$depth >= 39.5 & quakes$depth <= 80.5] <- 'd1'
quakes$depth3[quakes$depth >= 79.5 & quakes$depth <= 186.5] <- 'd2'
quakes$depth3[quakes$depth >= 185.5 & quakes$depth <= 397.5] <- 'd3'
quakes$depth3[quakes$depth >= 396.5 & quakes$depth <= 562.5] <- 'd4'
quakes$depth3[quakes$depth >= 562.5 & quakes$depth <= 680.5] <- 'd5'
# mag 변수 리코딩
quakes$mag3[quakes$mag >= 3.95 & quakes$mag <= 4.65] <- 'm1'
quakes$mag3[quakes$mag >= 4.55 & quakes$mag <= 6.45] <- 'm2'
View(quakes)
str(quakes)
convert <- transform(quakes, depth3=factor(depth3), mag3=factor(mag3))
str(convert)
xyplot(lat ~ long | depth3*mag3, data=convert,
main="Fiji Earthquakes",
ylab = "latitude", xlab = "longitude",
pch="@", col=c("red", "blue"))
# 위도, 경도, 깊이를 이용하여 3차원 산점도 그래프 그리기
cloud(depth ~ lat * long, data = quakes,
zlim = rev(range(quakes$depth)),
xlab = "경도", ylab = "위도", zlab = "깊이")
xyplot(lat ~ long | depth3*mag3, data=convert,
main="Fiji Earthquakes",
ylab = "latitude", xlab = "longitude",
pch="@", col=c("red", "blue"))
# 2.7 조건 그래프(graphics 패키지에서 제공)
coplot(lat~long | depth, data = quakes) # default:6개영역, 0.5단위로 겹침.
#사진3.
coplot(lat~long | depth, data = quakes, overlap = 0.1) # 겹치는 구간:0.1
#사진4.
coplot(lat~long | depth, data = quakes, number = 5, row = 1) # 사이간격 5, 1행 5열
# 패널과 조건 막대에 색 적용 후 조건 그래프 그리기
coplot(lat~long | depth, data = quakes, number = 5, row=1,
panel=panel.smooth)
coplot(lat~long | depth, data = quakes, number = 5, row=1,
col="blue", bar.bg = c(num="green")) # 패널과 조건 막대 색
# 패널과 조건 막대에 색 적용 후 조건 그래프 그리기
coplot(lat~long | depth, data = quakes, number = 5, row=1,
panel=panel.smooth)
# 패널과 조건 막대에 색 적용 후 조건 그래프 그리기
coplot(lat~long | depth, data = quakes, number = 5, row=1,
panel=panel.smooth)
#사진4.
coplot(lat~long | depth, data = quakes, number = 5, row=1,
col="blue", bar.bg = c(num="green")) # 패널과 조건 막대 색
# 위도, 경도, 깊이를 이용하여 3차원 산점도 그래프 그리기
cloud(depth ~ lat * long, data = quakes,
zlim = rev(range(quakes$depth)),
xlab = "경도", ylab = "위도", zlab = "깊이")
#사진5.
help(coplot)
# 테두리와 회전 속성을 추가하여 3차원 산점도 그래프 그리기
cloud(depth ~ lat * long, data = quakes,
zlim = rev(range(quakes$depth)),
panel.aspect=0.9,
screen=list(z=45, x=-25),
xlab = "경도", ylab = "위도", zlab = "깊이") # panel.aspect:테두리사이즈, screen : 회전각
install.packages("ggplot2")
library(ggplot2)
library(ggplot2)
data("mpg")
View(mpg)
str(mpg)
str(mpg)
class(mpg)
summary(mpg)
# (1) 한 개 변수 대상 qplot() 함수 적용
help(qplot)
# fill 속성: hwy 변수를 대상으로 drv 변수에 색 채우기(누적 막대 그래프)
qplot(hwy, data=mpg, fill=drv) # fill 옵션 적용
# binwidth 속성: 막대 폭 지정 옵션
qplot(hwy, data=mpg, fill=drv, binwidth=2) # binwidth 옵션 적용(막대의 폭 크기 지정)
# facets 속성:drv 변수 값으로 컬럼 단위와 행 단위로 패널 생성
qplot(hwy, data=mpg, fill=drv, facets = .~ drv, binwidth=2) # 열 단위 패널 생성
qplot(hwy, data=mpg, fill=drv, facets = drv ~. , binwidth=2) # 행 단위 패널 생성
qplot(data=mpg, x=hwy) # 세로 막대 그래프
# (2) 두 개 변수 대상 qplot() 함수 적용.
qplot(displ, hwy, data=mpg) # mpg 데이터 셋의 displ과 hwy 변수 이용(산점도).
# displ, hwy 대상으로 drv 변수값으로 색상 적용 산점도 그래프
qplot(displ, hwy, data=mpg, color=drv)
# displ과 hwy 변수와 관계를 drv로 구분
qplot(displ, hwy, data=mpg, color=drv, facets=.~drv)
View(mtcars)
str(mtcars) # 'data.frame':	32 obs. of  11 variables:
table(mtcars$carb)
table(mtcars$carb)
# 1  2  3  4  6  8
# 7 10  3 10  1  1
table(mtcars$cyl)
qplot(wt,mpg,data=mtcars)
qplot(wt,mpg,data=mtcars,color=factor(carb)) # 색상 적용
# 4) 조화평균 : 주로 평균 속도를 구할 때 사용하는 방법.
#   ex) 서울에서 강원도로 휴가를 가는데 갈 때는 안 막혀서 시속 100km로 갔는데, 올 때는 너무 막혀서 시속 60km였다면 왕복 평균 속력은 얼마일까요?
#   ans) 조화 평균의 식 : 2xy / (x+y) = 2(100*60) / (100+60) =
end <- 2(100*60) / (100+60);
# 4) 조화평균 : 주로 평균 속도를 구할 때 사용하는 방법.
#   ex) 서울에서 강원도로 휴가를 가는데 갈 때는 안 막혀서 시속 100km로 갔는데, 올 때는 너무 막혀서 시속 60km였다면 왕복 평균 속력은 얼마일까요?
#   ans) 조화 평균의 식 : 2xy / (x+y) = 2(100*60) / (100+60) =
end <- (2*(100*60) / (100+60));
end
# 4) 조화평균 : 주로 평균 속도를 구할 때 사용하는 방법.
#   ex) 서울에서 강원도로 휴가를 가는데 갈 때는 안 막혀서 시속 100km로 갔는데, 올 때는 너무 막혀서 시속 60km였다면 왕복 평균 속력은 얼마일까요?
#   ans) 조화 평균의 식 : 2xy / (x+y) = 2(100*60) / (100+60) = 75
end <- 2*(100*60) / (100+60);
end
# 실습 데이터 셋 가져오기
data <- read.csv("c:/workspaces/RLAB/data/descriptive.csv", header = T)
View(data)
# 실습 데이터 셋 가져오기
data <- read.csv("c:/workspaces/RLAB/data/descriptive.csv", header = T)
View(data)
View(data)
# 데이터 특성 보기
dim(data) # 300 8 - 차원보기
length(data) # 8
length(data$survey) # 300
str(data) # 'data.frame':	300 obs. of  8 variables:
str(data$survey)
# 데이터 특성(최소, 최대, 중위수, 평균, 분위수, 노이즈-NA) 제공
summary(data)
# 2.1 명목척도 기술 통계량
length(data$gender) # 300
summary(data$gender)
table(data$gender) # 각 성별 빈도 수 - outlier(이상치)-> 0, 5
# 이상치 제거
data <- subset(data, data$gender==1 | data$gender==2) # 성별 outlier 제거.
x <- table(data$gender) # 성별에 대한 빈도 수 저장.
x
table(data$gender) # 각 성별 빈도 수 - outlier(이상치)-> 0, 5
# 2.1 명목척도 기술 통계량
length(data$gender) # 300
summary(data$gender)
x11()
barplot(x) # 범주형(명목/서열 척도) 시각화 -> 막대차트
x11() # 별도의 시각화 자료를 보는 창을 띄움
#사진1
barplot(x) # 범주형(명목/서열 척도) 시각화 -> 막대차트
# 구성비율 계산
prop.table(x) # 비율계산: 0 < x < 1 사이의 값
y <- prop.table(x)
round(y*100, 2) # 백분율 적용(소수점 2자리)
# 2.2 서열척도 기술 통계량
length(data$level) # 297 : 학력수준 - 서열.
summary(data$level) # 명목척도와 함께 의미없음.
table(data$level) # 빈도분석 - 의미있음.
# 학력 수준(level) 변수의 빈도 수 시각화
x1 <- table(data$level) # 각 학력수준에 빈도수 저장.
x11()
barplot(x1)  # 명목/서열 척도 -> 막대차트
# 구성비율 계산
y <- prop.table(x1)
round(y*100,2) # 백분율 적용
# 구성비율 계산
y <- prop.table(x1)
round(y*100,2) # 백분율 적용
# 2.3 등간척도 기술 통계량
# 만족도(survey) 변수 대상 요약 통계량 구하기
survey <- data$survey
survey
summary(survey) # 만족도(5점척도)인 경우 의미 있음 -> 2.605(평균)
# Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's
#1.000   2.000   3.000   2.605   3.000   5.000     112
x1 <- table(survey) # 빈도 수
x1
hist(survey) # 등간척도 시각화
hist(survey) # 등간척도 시각화
hist(survey) # 등간척도 시각화
hist(survey) # 등간척도 시각화
x11()
hist(survey) # 등간척도 시각화
pie(x1)
hist(survey) # 등간척도 시각화
#사진1.
pie(x1)
# 생활비(cost) 변수 대상 요약 통계량 구하기
length(data$cost) # 297
summary(data$cost) # 요약통계량-의미있음(mean)-8.784, 중위수-3.000
plot(data$cost)
# 데이터 정제(이상치 제거)
data <- subset(data, data$cost >= 2 & data$cost <= 10) # 총점기준
data
plot(data$cost)
x <- data$cost
mean(x) # 5.354032
summary(data$cost)
# 생활비(cost) 변수 대상 대표값 구하기
mean(x)
median(x)
sort(x) # 오름차순
sort(x, decreasing=T) # 내림차순
# 생활비(cost) 변수 대상 사분위수 구하기
quantile(x, 1/4) # 4.6
quantile(x, 2/4) # 5.4
quantile(x, 3/4) # 6.2
quantile(x, 4/4) # 7.9
# 생활비(cost) 변수의 최빈수(빈도 수가 가장 많은 변수) 구하기
length(x) # [1] 248
x.t <- table(x)
x.t
max(x.t) # [1] 18
x.m <- rbind(x.t)
x.m
class(x.m) # [1] "matrix"
str(x.m)
which(x.m[1, ] == 18) # 1행 전체를 대상으로 18값 찾기.
x.df <- as.data.frame(x.m)
class(x.df)
which(x.df[1, ] == 18) # [1] 19(index)
x.df[1, 19] # [1] 18
attributes(x.df) # $names, $class, $row.names
names(x.df[19]) # [1] "5"
# 생활비(cost) 변수 대상 산포도 구하기
var(x) # 분산, [1] 1.296826
sd(x)  # 표준편차, [1] 1.138783
# 분산 -> 표준편차
sqrt(var(x))
# 표준편차 -> 분산
sd(x) ** 2
# 표준편차 -> 분산
sd(x) *** 2
# 표준편차 -> 분산
sd(x) ** 3
# 생활비(cost) 변수의 빈도분석과 시각화
table(data$cost)
hist(data$cost) # 히스토그램 시각화
#사진3,
plot(data$cost) # 산점도 시각화
# 연속형 변수 범주화
data$cost2[data$cost >= 2 & data$cost < 4] <- 1
data$cost2[data$cost >= 4 & data$cost < 7] <- 2
data$cost2[data$cost >= 7] <- 3
x <- table(data$cost2)
barplot(x)
#사진5.
pie(x)
# 2.5 비대칭도 구하기
install.packages("moments")
library(moments)
cost <- data$cost
cost
# 왜도 - 평균을 중심으로 기울어진 정도.
skewness(cost) # [1] -0.297234
# 첨도 - 표준 정규 분포와 비교하여 얼마나 뽀족한가 측정 지표
kurtosis(cost) # [1] 2.674163
# 기본 히스토그램
hist(cost)
# 히스토그램 확률밀도/표준 정규 분포 곡선
hist(cost, freq = F)
# 확률 밀도 분포 곡선
lines(density(cost), col='blue')
# attach() / detach() 함수로 기술 통계량 구하기
# - 기존 선언 변수와 컬럼의 이름이 중복시 기존 변수가 global 변수로 잡힘.
search()
attach(iris)
search()
summary(Sepal.Width) # 요약 통계량 - 의미있음(mean)
# 3.1 Hmisc 패키지 이용
install.packages("Hmisc")
library(Hmisc)
# 첨도 - 표준 정규 분포와 비교하여 얼마나 뽀족한가 측정 지표
kurtosis(cost) # [1] 2.674163
# 기본 히스토그램
hist(cost)
# 히스토그램 확률밀도/표준 정규 분포 곡선
hist(cost, freq = F)
# 히스토그램 확률밀도/표준 정규 분포 곡선
hist(cost, freq = F)
# 기본 히스토그램
hist(cost)
# 히스토그램 확률밀도/표준 정규 분포 곡선
hist(cost, freq = F)
# 확률 밀도 분포 곡선
lines(density(cost), col='blue')
# 표준정규분포 곡선
x <- seq(0, 8, 0.1)
x
curve(dnorm(x, mean(cost), sd(cost)), col='red', add = T)
# attach() / detach() 함수로 기술 통계량 구하기
# - 기존 선언 변수와 컬럼의 이름이 중복시 기존 변수가 global 변수로 잡힘.
search()
attach(iris)
search()
length(Sepal.Width)
summary(Sepal.Width) # 요약 통계량 - 의미있음(mean)
mean(Sepal.Width)
min(Sepal.Width)
max(Sepal.Width)
range(Sepal.Width) # [1] 2.1(min) ~ 7.9(max)
var(Sepal.Width, na.rm = T)
sd <- sd(Sepal.Width, na.rm = T)
sqrt(var(Sepal.Width, na.rm=T))
sort(Sepal.Width) # 오름차순
sort(Sepal.Width, decreasing = T) # 내림차순
detach(iris)
attach(data) # data$cost 접근.
search()
length(cost) # [1] 248
summary(cost) # 요약 통계량 - 의미있음(mean)
mean(cost)
min(cost)
max(cost)
range(cost) # [1] 2.1(min) ~ 7.9(max)
var(cost, na.rm = T)
sd <- sd(cost, na.rm = T)
sqrt(var(cost, na.rm=T))
sort(cost) # 오름차순
sort(cost, decreasing = T) # 내림차순
detach(data)
desc::
# 전체 변수 대상 기술통계량 제공 - 빈도와 비율 데이터 일괄 수행
describe(data)
# 전체 변수 대상 기술통계량 제공 - 빈도와 비율 데이터 일괄 수행
describe(data)
# 개별 변수 기술 통계량
describe(data$gender) # 특정 변수(명목) 기술통계량-범주/빈도수/비율 제공.
describe(data$age) # 특정 변수(비율) 기술통계량 - lowest / highest
describe(data$age) # 특정 변수(비율) 기술통계량 - lowest / highest
summary(data$age)
# 3.2 prettyR 패키지 이용
install.packages("prettyR")
library(prettyR)
# 전체 변수 대상
freq(data) # 각 변수별 : 빈도, 결측치, 백분율, 특징-소수점 제공
# 1) 거주지역 변수 리코딩과 비율 계산
data$resident2[data$resident==1] <- "특별시"
data$resident2[data$resident>=2 & data$resident<=4] <- "광역시"
data$resident2[data$resident==5] <- "시구군"
freq(data$resident2)
# 2) 성별 변수 리코딩과 비율 계산
data$gender2[data$gender==1] <- "남자"
data$gender2[data$gender==2] <- "여자"
freq(data$gender2)
# 3) 나이 변수 리코딩과 비율 계산
summary(data$age)
data$age2[data$age <= 45] <- "중년층"
data$age2[data$age >= 46 & data$age <= 59] <- "장년층"
data$age2[data$age >= 60] <- "노년층"
freq(data$age2)
# 4) 학력 수준 변수 리코딩과 비율계산
data$level2[data$level == 1] <- "고졸"
data$level2[data$level == 2] <- "대졸"
freq(data$level2)
# 최종 결론과 관련된 내용은 pdf를 참조.
View(data)
# 1) 실습 파일 가져오기
data <- read.csv("C:/workspaces/RLAB/data/cleanDescriptive.csv", header = T)
# 1) 실습 파일 가져오기
data <- read.csv("C:/workspaces/RLAB/data/cleanDescriptive.csv", header = T)
View(data)
head(data) # 변수 확인
# 2) 변수 리코딩
x <- data$level2 # 리코딩 변수 이용(학력수준)
y <- data$pass2  # 리코딩 변수 이용(합격/불합격)
x; y  # 부모학력수준(x) -> 자녀대학진학여부(y)
# 3) 데이터프레임 생성
result <- data.frame(Level=x, Pass=y) # 데이터 프레임 생성 - 데이터 묶음.
dim(result) # 차원보기(248,2)
head(result)
View(result)
# 1) 교차 분할표 작성
table(result) # 빈도보기
# 2) 교차분할표 생성을 위한 패키지 설치
install.packages("gmodels")
library(gmodels)
# 3) 패키지를 이용한 교차 분할표 생성
CrossTable(x, y)
# 3) 패키지를 이용한 교차 분할표 생성
CrossTable(x, y)
# 교차테이블에 카이검정 적용
CrossTable(x, y, chisq = T)
## 2. 카이제곱 검정
x11()
chisq.test(c(4,6,17,16,8,9))
chisq.test(c(4,6,17,16,8,9))
chisq.test(c(4,6,17,16,8,9))
# 5개 제품의 스포츠 음료에 대한 선호도에 차이가 있는지 검정
data <- textConnection(
"스포츠음료종류  관측도수
1               41
2               30
3               51
4               71
5               61
")
class(data)
x <- read.table(data, header = T)
x # 스포츠음료종류   관측도수
str(x)
chisq.test(x$관측도수)
x <- read.table(data, header = T)
x # 스포츠음료종류   관측도수
class(data)
x <- read.table(data, header = T)
x # 스포츠음료종류   관측도수
str(x)
chisq.test(x$관측도수)
data <- read.csv("C:/workspaces/RLAB/data/cleanDescriptive.csv", header = T)
# 독립변수(x) = 설명변수, 종속변수(y) = 반응 변수 생성
x <- data$level2 # 부모의 학력수준
y <- data$pass2  # 자녀의 대학 진학 여부
CrossTable(x, y, chisq = T)
# 1. 파일 가져오기
data <- read.csv("C:/workspaces/RLAB/data/homogenity.csv", header = T)
View(data)
# 1. 파일 가져오기
data <- read.csv("C:/workspaces/RLAB/data/homogenity.csv", header = T)
View(data)
table(data$method) # 교육방법
table(data$survey) # 만족도
# 전처리 - 결측치/ method와 survey 변수만 서브셋 생성
data <- subset(data, !is.na(survey), c(method, survey))
data
length(data$survey) # 150
# method2 필드 추가
data$method2[data$method == 1] <- "방법1"
data$method2[data$method == 2] <- "방법2"
data$method2[data$method == 3] <- "방법3"
# survey2 필드 추가
data$survey2[data$survey == 1] <- "1. 매우만족"
data$survey2[data$survey == 2] <- "2. 만족"
data$survey2[data$survey == 3] <- "3. 보통"
data$survey2[data$survey == 4] <- "4. 불만족"
data$survey2[data$survey == 5] <- "5. 매우불만족"
# 3. 교차분할표 작성
table(data$method2, data$survey2) # 교차표 생성 -> table(행, 열)
#         1. 매우만족 2. 만족 3. 보통 4. 불만족 5. 매우불만족
#방법1           5       8      15        16             6
#방법2           8      14      11        11             6
#방법3           8       7      11        15             9
View(data)
# 4. 교차분할표 생성
CrossTable(data$method2, data$survey2, chisq = T)
# 5. 동질성 검정 - 모수 특성치에 대한 추론 검정
chisq.test(data$method2, data$survey2)
# 단계1. 실습데이터 가져오기
data <- read.csv("C:/workspaces/RLAB/data/one_sample.csv", header = T)
head(data)
View(data)
# 단계2. 빈도수와 비율 계산
x <- data$survey
x
summary(x) # 결측치 확인
length(x) # [1] 150
table(x) # 빈도수(0:불만족(14), 1:만족(136))
# 단계3. 패키지 이용 빈도수와 비율계산
install.packages("prettyR")
install.packages("prettyR")
library(prettyR) # freq() 함수 사용
freq(x)
# 이항분포 (불만족율 기준) 비율검정(양측검정)
binom.test(14, 150, p = 0.2) # p-value = 0.0006735
binom.test(14, 150, p = 0.2, alternative = "two.sided", conf.level = 0.95)
