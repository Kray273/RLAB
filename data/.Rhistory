# - 분포곡선:빈도수의 값을 선으로 연결하여 얻어진 곡선.
x <- seq(2.0, 4.5, 0.1)
x
curve(dnorm(x, mean=mean(iris$Sepal.Width), sd=sd(iris$Sepal.Width)),
col="blue", add=T)
# 기본 산점도 시각화
price <- runif(10, min = 1, max = 100) # 1~100 사이의 10개 난수 발생.
plot(price)
# 대각선 추가
par(new=T) # 차트 추가
price
plot(price)
# 대각선 추가
par(new=T) # 차트 추가
line_chart <- c(1:100)
line_chart
plot(line_chart, type = "l", col="red", axes = F, ann = F)
# 텍스트 추가
text(70, 80, "대각선 추가", col="blue")
# type 속성으로 그리기
par(mfrow=c(2,2)) # 2행 2열 차트 그리기
plot(price, type = "l") # 유형:실선
plot(price, type = "o") # 유형:원형과 실선(원형통과)
plot(price, type = "h") # 유형:직선
plot(price, type = "s") # 유형:꺽은선
# pch 속성으로 그리기
plot(price, type="o", pch=5) # 빈 사각형
plot(price, type="o", pch=15) # 채워진 사각형
plot(price, type="o", pch=20) # 채워진 원형
plot(price, type="o", pch=20, col="blue")
plot(price, type="o", pch=20, col="orange", cex=3.0)
plot(price, type="o", pch=20, col="orange", cex=3.0, lwd=3) # lwd:line width
# pch 속성으로 그리기
plot(price, type="o", pch=5) # 빈 사각형
plot(price, type="o", pch=15) # 채워진 사각형
plot(price, type="o", pch=20) # 채워진 원형
plot(price, type="o", pch=20, col="blue")
# pch 속성으로 그리기
plot(price, type="o", pch=5) # 빈 사각형
plot(price, type="o", pch=15) # 채워진 사각형
# pch 속성으로 그리기
plot(price, type="o", pch=5) # 빈 사각형
plot(price, type="o", pch=15) # 채워진 사각형
plot(price, type="o", pch=20) # 채워진 원형
plot(price, type="o", pch=20, col="blue")
#사진 12.
plot(price, type="o", pch=20, col="orange", cex=3.0)
plot(price, type="o", pch=20, col="orange", cex=3.0, lwd=3) # lwd:line width
new_data <- read.csv("new_data.csv", header = T)
# 5.1 범주형 vs 범주형
getwd()
setwd("C:/workspaces/RLAB/data")
new_data <- read.csv("new_data.csv", header = T)
View(new_data)
# 만족도(survey)를 긍정순서로 역코딩
survey <- dataset2$survey
csurvey <- 6-survey # 역코딩
csurvey
mean(dataset2$survey2, na.rm = T) # 3.358566
# 나이(age/연속형) vs 직업(job2/범주형) 데이터 분포 시각화
install.packages("lattice") # chap08
library(lattice)
# 5.1 범주형 vs 범주형
getwd()
setwd("C:/workspaces/RLAB/data")
new_data <- read.csv("new_data.csv", header = T)
new_data <- read.csv("new_data.csv", header = T)
View(new_data)
## 성별에 따른 거주지역 분포 현황
resident_gender <- table(new_data$resident2, new_data$gender2)
resident_gender
barplot(resident_gender, beside = T, horiz = F,
col=rainbow(5),
legend=row.names(resident_gender),
main="성별에 따른 거주지역 분포 현황")
## 거주지역에 따른 성별 분포 현황
gender_resident <- table(new_data$gender2, new_data$resident2)
gender_resident
barplot(gender_resident, beside = T, horiz = F,
col=rainbow(2),
legend=row.names(gender_resident),
main="거주지역에 따른 성별 분포 현황")
barplot(gender_resident, beside = T, horiz = T,
col=rainbow(2),
legend=row.names(gender_resident),
main="거주지역에 따른 성별 분포 현황")
barplot(gender_resident, beside = F, horiz = T,
col=rainbow(2),
legend=row.names(gender_resident),
main="거주지역에 따른 성별 분포 현황")
## 성별에 따른 거주지역 분포 현황
resident_gender <- table(new_data$resident2, new_data$gender2)
resident_gender
barplot(resident_gender, beside = T, horiz = F,
col=rainbow(5),
legend=row.names(resident_gender),
main="성별에 따른 거주지역 분포 현황")
## 거주지역에 따른 성별 분포 현황
gender_resident <- table(new_data$gender2, new_data$resident2)
gender_resident
barplot(gender_resident, beside = T, horiz = F,
col=rainbow(2),
legend=row.names(gender_resident),
main="거주지역에 따른 성별 분포 현황")
barplot(gender_resident, beside = T, horiz = F,
col=rainbow(2),
legend=row.names(gender_resident),
main="거주지역에 따른 성별 분포 현황")
barplot(gender_resident, beside = T, horiz = F,
col=rainbow(2),
legend=row.names(gender_resident),
main="거주지역에 따른 성별 분포 현황")
## 거주지역에 따른 성별 분포 현황
gender_resident <- table(new_data$gender2, new_data$resident2)
gender_resident
barplot(gender_resident, beside = T, horiz = F,
col=rainbow(2),
legend=row.names(gender_resident),
main="거주지역에 따른 성별 분포 현황")
barplot(gender_resident, beside = T, horiz = T,
col=rainbow(2),
legend=row.names(gender_resident),
main="거주지역에 따른 성별 분포 현황")
barplot(gender_resident, beside = F, horiz = T,
col=rainbow(2),
legend=row.names(gender_resident),
main="거주지역에 따른 성별 분포 현황")
barplot(gender_resident, beside = F, horiz = F,
col=rainbow(2),
legend=row.names(gender_resident),
main="거주지역에 따른 성별 분포 현황")
# 나이(age/연속형) vs 직업(job2/범주형) 데이터 분포 시각화
install.packages("lattice") # chap08
install.packages("lattice")
library(lattice)
# 직업유형에 따른 나이 분포 현황
?densityplot
densityplot( ~ age, data=new_data, groups = job2,
plot.points=T, auto.key = T)
(x), auto.key=T:범례
# (1) 성별에 따른 직급별 구매비용 분포 현황 분석
densityplot( ~ price|factor(gender2), data=new_data,
groups = position2,
plot.points=T, auto.key = T)
# (2) 직급에 따른 성별 구매비용 분포 현황 분석
densityplot( ~ price|factor(position2), data=new_data,
groups = gender2,
plot.points=T, auto.key = T)
# price(연속형) vs age(연속형) vs gender2(범주형)
xyplot(price ~ age|factor(gender2), data=new_data)
# (2) 직급에 따른 성별 구매비용 분포 현황 분석
densityplot( ~ price|factor(position2), data=new_data,
groups = gender2,
plot.points=T, auto.key = T)
# price(연속형) vs age(연속형) vs gender2(범주형)
xyplot(price ~ age|factor(gender2), data=new_data)
# 데이터 파일 가져오기
getwd()
setwd("C:/workspaces/RLAB/src/data")
# 데이터 파일 가져오기
getwd()
setwd("C:/workspaces/RLAB/src/data")
# 데이터 파일 가져오기
getwd()
setwd("C:/workspaces/RLAB/data")
user_data <- read.csv('user_data.csv', header = T)
user_data <- read.csv('user_data.csv', header = T)
user_data <- read.csv('user_data.csv', header = T)
View(user_data)
user_data <- read.csv('user_data.csv', header = T)
View(user_data)
table(user_data$house_type)
# 더미변수 생성
# 주택유형(단독주택, 빌라) : 0, 아파트 유형(아파트, 오피스텔) : 1
house_type2 <- ifelse(user_data$house_type==1 | user_data$house_type==2, 0, 1)
house_type2[1:10]
head(house_type2, 10)
# 파생변수 추가
user_data$house_type2 <- house_type2
View(user_data)
# 데이터 파일 가져오기
pay_data <- read.csv('pay_data.csv', header = T)
# 데이터 파일 가져오기
pay_data <- read.csv('pay_data.csv', header = T)
View(pay_data)
table(pay_data$product_type)
# 고객별 상품유형에 따른 구매금액 합계 파생변수 생성
library(reshape2) # 구조 변경을 위한 패키지 로딩.
# 고객별 상품유형에 따른 구매금액 합계 파생변수 생성
library(reshape2) # 구조 변경을 위한 패키지 로딩.
# 고객별 상품유형에 따른 구매금액 합계 파생변수 생성
install.packages("reshape2")
library(reshape2) # 구조 변경을 위한 패키지 로딩.
product_price <- dcast(pay_data,user_id ~ product_type, sum, na.rm=T)
product_price <- dcast(pay_data,user_id ~ product_type, sum, na.rm=T)
View(product_price)
View(pay_data)
View(pay_data)
# 컬럼명 수정
names(product_price) <- c('user_id', '식료품(1)', '생필품(2)', '의류(3)', '잡화(4)', '기타(5)')
head(product_price) # 컬럼명 수정 확인.
# 고객별 지불유형에 따른 구매상품 개수 파생변수 생성
pay_price <- dcast(pay_data,user_id ~ pay_method, length)
View(pay_price)
# 고객 정보 테이블에서 파생변수 추가
install.packages("plyr")
install.packages("plyr")
library(plyr)
user_pay_data <- join(user_data, product_price, by='user_id')
View(user_pay_data)
# 병합(위에 결과)된 데이터를 대상으로 고객별 지불 유형에 다른 구매상품 개수 병합하기
user_pay_data <- join(user_pay_data, pay_price, by='user_id')
View(user_pay_data)
write.csv(user_pay_data, "cleanData.csv", quote = F, row.names = F)
data <- read.csv("cleanData.csv", header = T)
data <- read.csv("cleanData.csv", header = T)
View(data)
# 표본 추출하기
nrow(data) # 400, data의 행수 구하기(Number of Rows)
choice1 <- sample(nrow(data), 30) # 30개 무작위 추출
choice1
data[choice1, 1]
# 50~data 길이 사이에서 30개 무작위 추출
choice2 <- sample(50:nrow(data), 30)
choice2
# 다양한 범위를 지정해서 무작위 샘플링
choice3 <- sample(c(10:50, 80:150, 160:190), 30)
choice3
# iris 데이터 셋을 대상으로 7:3 비율로 데이터 셋 생성.
data("iris")
dim(iris) # 150   5
idx <- sample(1:nrow(iris), nrow(iris) * 0.7)
training <- iris[idx,] # 학습데이터 셋
testing <- iris[-idx,] # 검정데이터 셋
dim(training) # 105  5
dim(testing)  #  45  5
View(data)
# 데이터 셋을 대상으로 K겹(fold) 교차 검정 데이터 셋 생성.
name <- c('a','b','c','d','e','f')
score <- c(90, 85, 70, 85, 60, 74)
df <- data.frame(Name=name, Score=score)
df
# 교차 검정을 위한 패키지 설치
install.packages("cvTools")
library(cvTools)
library(cvTools)
cross <- cvFolds(n=6, K=3, R=1, type = "random")
cross
str(cross)
# which를 이용하여 subsets 데이터 참조
cross$subsets[cross$which == 1, 1] # k=1인 경우
cross$subsets[cross$which == 2, 1] # k=2인 경우
cross$subsets[cross$which == 3, 1] # k=3인 경우
r <- 1 # 1회전
K <- 1:3 # 3겹(fold)
for(k in K){ # 3회전
datas_idx <- cross$subsets[cross$which==k,r]
cat('k=', k, '검정데이터\n')
print(df[datas_idx,])
cat('훈련데이터\n')
print(df[-datas_idx,])
}
# which를 이용하여 subsets 데이터 참조
cross$subsets[cross$which == 1, 1] # k=1인 경우
for(k in K){ # 3회전
datas_idx <- cross$subsets[cross$which==k,r]
cat('k=', k, '검정데이터\n')
print(df[datas_idx,])
cat('훈련데이터\n')
print(df[-datas_idx,])
}
## 2. 격자형(lattice) 기법 시각화(lattice package)
# 패키지 설치와 실습 데이터 셋 가져오기
install.packages("lattice")
install.packages("lattice")
library(lattice)
install.packages(c("statmod", "lme4", "mlmRev"))
library(statmod)
library(lme4)
library(mlmRev)
data("Chem97")
library(lme4)
library(mlmRev)
data("Chem97")
View(Chem97)
str(Chem97) # 'data.frame':	31022 obs. of  8 variables:
table(Chem97$score)
#   0    2    4    6    8   10
#3688 3627 4619 5739 6668 6681
range(Chem97$gcsescore) # 0~8
range(Chem97$age) # -6(1월생)~5(12월생)
histogram(~ gcsescore, data = Chem97) # gcsescore 변수를 대상으로 백분율 적용 히스토그램.
table(Chem97$score)
# score 변수를 조건으로 지정.
histogram(~ gcsescore|score, data = Chem97) # score 단위
# score 변수를 조건으로 지정.
table(Chem97$score)
# score 변수를 조건으로 지정.
range(Chem97$score)
histogram(~ gcsescore|factor(score), data = Chem97) # score 요인 단위
# 2.2 밀도 그래프
# - 형식) densityplot(~축컬럼|조건,data,groups=변수)
# - 성별 변수를 그룹으로 지정하여 GCSE 점수를 score 단위로 밀도그래프를 플로팅.
densityplot(~ gcsescore|factor(score), data = Chem97,
groups = gender, plot.points=F, auto.key = T)
# 1) 데이터셋 가져오기
data("VADeaths")
VADeaths
str(VADeaths)
# 2) 데이터셋 구조보기
mode(VADeaths) # "numeric"
class(VADeaths) # "matrix"
# 2.3 막대 그래프
#  - 형식) barchart(y축컬럼~x축컬럼|조건,data,layout)
?barchart
# 2.3 막대 그래프
#  - 형식) barchart(y축컬럼~x축컬럼|조건,data,layout)
?barchart()
# 3) 데이터 형식 변경
#   (1) matrix -> dataframe 변환
df <- as.data.frame(VADeaths)
str(df) # 'data.frame':	5 obs. of  4 variables:
class(df) # "data.frame"
df
#   (2) 막대그래프 그리기 - 데이터 형식 변경(matrix 형식을 table 형식으로 변경)
dft <- as.data.frame.table(VADeaths)
str(dft) # 'data.frame':	20 obs. of  3 variables:
dft # Var1 Var2 Freq -> 1열 기준으로 data.table 생성
# 막대그래프 그리기
barchart(Var1~Freq|Var2, data=dft)
#사진1.
barchart(Var1~Freq|Var2, data=dft, layout=c(4,1))
barchart(Var1~Freq|Var2, data=dft, layout=c(4,1), origin=0) # origin 속성 : x축의 구간을 0부터 표시해 주는 역할.
barchart(Var1~Freq|Var2, data=dft, layout=c(4,1), origin=0) # origin 속성 : x축의 구간을 0부터 표시해 주는 역할.
#사진1.
barchart(Var1~Freq|Var2, data=dft, layout=c(4,1))
barchart(Var1~Freq|Var2, data=dft, layout=c(4,1), origin=0) # origin 속성 : x축의 구간을 0부터 표시해 주는 역할.
# 2.4 점 그래프
# - 형식) dotplot(y축컬럼~x축컬럼|조건,data,layout)
dotplot(Var1~Freq|Var2, dft) # layout 속성 생략시 기본 : 2행 2열 구조의 패널.
#사진1
dotplot(Var1~Freq|Var2, dft,layout=c(1,4))
# Var2 변수 단위로 그룹화하여 점을 연결하여 플로팅.
dotplot(Var1 ~ Freq,data=dft, groups=Var2, type="o",
auto.key=list(space="right",points=T,lines=T))
# 2.5 산점도 그래프
# -형식) xyplot(y축컬럼~x축컬럼|조건변수, data=data.frame or list, layout)
library(datasets)
str(airquality) # data.frame':	153 obs. of  6 variables:
head(airquality) # Ozone Solar.R Wind Temp Month Day
View(airquality)
# airquality의 Ozone(y), Wind(x) 산점도 플로팅
names(airquality) <- c('Ozone','Solar.R','Wind', 'Temp', 'Month','Day')
xyplot(Ozone ~ Wind, data = airquality)
#사진2.
range(airquality$Ozone, na.rm = T) # 1~168
View(airquality)
xyplot(Ozone ~ Wind | Month, data = airquality) # 2행 3컬럼
#사진3.
xyplot(Ozone ~ Wind | Month, data = airquality, layout=c(5, 1)) # layout=c(5, 1):5개의 패널을 1행으로 출력.
#사진4.
xyplot(Ozone ~ Wind | factor(Month), data = airquality, layout=c(5, 1)) # factor(Month) : 범주값으로 출력.
# airquality 데이터셋의 Month 타입 변경(factor)
convert <- transform(airquality, Month=factor(Month))
str(convert)  # $ Month : Factor w/ 5 levels "5","6","7","8",..:
head(convert)
xyplot(Ozone ~ Wind | Month, data = convert, layout=c(5, 1))
# quakes 데이터 셋으로 산점도 그래프 그리기
head(quakes)
str(quakes)  # 'data.frame':	1000 obs. of  5 variables:
range(quakes$stations) # 10~132(관측소)
View(quakes)
# 지진 발생 위치(위도와 경도)
xyplot(lat~long, data=quakes, pch="o")
# 그래프를 변수에 저장
tplot <- xyplot(lat~long, data=quakes, pch=".")
# 그래프에 제목 추가
tplot2 <- update(tplot, main="1964년 이후 태평양에서 발생한 지진위치")
tplot2
# 산점도 그래프 그리기
# 1. depth 이산형 변수 범위 확인.
range(quakes$depth) # 40~680 : depth 범위
# 2. depth 변수 리코딩:6개의 범주(100단위)로 코딩 변경.
quakes$depth2[quakes$depth >= 40 & quakes$depth <= 150] <- 1
quakes$depth2[quakes$depth >= 151 & quakes$depth <= 250] <- 2
quakes$depth2[quakes$depth >= 251 & quakes$depth <= 350] <- 3
quakes$depth2[quakes$depth >= 351 & quakes$depth <= 450] <- 4
quakes$depth2[quakes$depth >= 451 & quakes$depth <= 550] <- 5
quakes$depth2[quakes$depth >= 551 & quakes$depth <= 680] <- 6
View(quakes)
# 3. 리코딩 변수(depth2)를 조건으로 산점도 그래프 그리기
convert <- transform(quakes, depth2 = factor(depth2))
xyplot(lat~long | depth2, data=convert)
# 동일한 패널에 2개의 y축에 값을 표현.
xyplot(Ozone+Solar.R ~ Wind | factor(Month),
data = airquality,
col=c("blue", "red"),
layout=c(5,1))
# (1) 1~150을 대상으로 겹쳐치지 않게 4개 영역으로 범주화
numgroup <- equal.count(1:150, number=4, overlap=0)
numgroup
# (2) 지진의 깊이를 5개 영역으로 범주화
depthgroup <- equal.count(quakes$depth, number=5, overlap=0)
depthgroup
# 범주화된 변수(depthgroup)를 조건으로 산점도 그래프 그리기
xyplot(lat~long | depthgroup, data = quakes,
main="Fiji Earthquakes(depthgroup)",
ylab="위도", xlab="경도",pch="@", col="red")
# 수심과 리히터규모 변수를 동시에 적용하여 산점도 그래프 그리기
magnitudegroup <- equal.count(quakes$mag, number=2, overlap=0)
magnitudegroup
# magnitudegroup 변수 기준으로 플로팅
xyplot(lat~long | magnitudegroup, data = quakes,
main="Fiji Earthquakes(magnitude)",
ylab = "latitude", xlab = "longitude",
pch="@", col="blue")
# 수심과 리히터 규모를 동시에 표현(2행 5열 패널 구조)
xyplot(lat~long | depthgroup*magnitudegroup, data=quakes,
main="Fiji Earthquakes",
ylab = "latitude", xlab = "longitude",
pch="@", col=c("red", "blue"))
# depth 변수 리코딩분
quakes$depth3[quakes$depth >= 39.5 & quakes$depth <= 80.5] <- 'd1'
quakes$depth3[quakes$depth >= 79.5 & quakes$depth <= 186.5] <- 'd2'
quakes$depth3[quakes$depth >= 185.5 & quakes$depth <= 397.5] <- 'd3'
quakes$depth3[quakes$depth >= 396.5 & quakes$depth <= 562.5] <- 'd4'
quakes$depth3[quakes$depth >= 562.5 & quakes$depth <= 680.5] <- 'd5'
# mag 변수 리코딩
quakes$mag3[quakes$mag >= 3.95 & quakes$mag <= 4.65] <- 'm1'
quakes$mag3[quakes$mag >= 4.55 & quakes$mag <= 6.45] <- 'm2'
View(quakes)
str(quakes)
convert <- transform(quakes, depth3=factor(depth3), mag3=factor(mag3))
str(convert)
xyplot(lat ~ long | depth3*mag3, data=convert,
main="Fiji Earthquakes",
ylab = "latitude", xlab = "longitude",
pch="@", col=c("red", "blue"))
# 위도, 경도, 깊이를 이용하여 3차원 산점도 그래프 그리기
cloud(depth ~ lat * long, data = quakes,
zlim = rev(range(quakes$depth)),
xlab = "경도", ylab = "위도", zlab = "깊이")
xyplot(lat ~ long | depth3*mag3, data=convert,
main="Fiji Earthquakes",
ylab = "latitude", xlab = "longitude",
pch="@", col=c("red", "blue"))
# 2.7 조건 그래프(graphics 패키지에서 제공)
coplot(lat~long | depth, data = quakes) # default:6개영역, 0.5단위로 겹침.
#사진3.
coplot(lat~long | depth, data = quakes, overlap = 0.1) # 겹치는 구간:0.1
#사진4.
coplot(lat~long | depth, data = quakes, number = 5, row = 1) # 사이간격 5, 1행 5열
# 패널과 조건 막대에 색 적용 후 조건 그래프 그리기
coplot(lat~long | depth, data = quakes, number = 5, row=1,
panel=panel.smooth)
coplot(lat~long | depth, data = quakes, number = 5, row=1,
col="blue", bar.bg = c(num="green")) # 패널과 조건 막대 색
# 패널과 조건 막대에 색 적용 후 조건 그래프 그리기
coplot(lat~long | depth, data = quakes, number = 5, row=1,
panel=panel.smooth)
# 패널과 조건 막대에 색 적용 후 조건 그래프 그리기
coplot(lat~long | depth, data = quakes, number = 5, row=1,
panel=panel.smooth)
#사진4.
coplot(lat~long | depth, data = quakes, number = 5, row=1,
col="blue", bar.bg = c(num="green")) # 패널과 조건 막대 색
# 위도, 경도, 깊이를 이용하여 3차원 산점도 그래프 그리기
cloud(depth ~ lat * long, data = quakes,
zlim = rev(range(quakes$depth)),
xlab = "경도", ylab = "위도", zlab = "깊이")
#사진5.
help(coplot)
# 테두리와 회전 속성을 추가하여 3차원 산점도 그래프 그리기
cloud(depth ~ lat * long, data = quakes,
zlim = rev(range(quakes$depth)),
panel.aspect=0.9,
screen=list(z=45, x=-25),
xlab = "경도", ylab = "위도", zlab = "깊이") # panel.aspect:테두리사이즈, screen : 회전각
install.packages("ggplot2")
library(ggplot2)
library(ggplot2)
data("mpg")
View(mpg)
str(mpg)
str(mpg)
class(mpg)
summary(mpg)
# (1) 한 개 변수 대상 qplot() 함수 적용
help(qplot)
# fill 속성: hwy 변수를 대상으로 drv 변수에 색 채우기(누적 막대 그래프)
qplot(hwy, data=mpg, fill=drv) # fill 옵션 적용
# binwidth 속성: 막대 폭 지정 옵션
qplot(hwy, data=mpg, fill=drv, binwidth=2) # binwidth 옵션 적용(막대의 폭 크기 지정)
# facets 속성:drv 변수 값으로 컬럼 단위와 행 단위로 패널 생성
qplot(hwy, data=mpg, fill=drv, facets = .~ drv, binwidth=2) # 열 단위 패널 생성
qplot(hwy, data=mpg, fill=drv, facets = drv ~. , binwidth=2) # 행 단위 패널 생성
qplot(data=mpg, x=hwy) # 세로 막대 그래프
# (2) 두 개 변수 대상 qplot() 함수 적용.
qplot(displ, hwy, data=mpg) # mpg 데이터 셋의 displ과 hwy 변수 이용(산점도).
# displ, hwy 대상으로 drv 변수값으로 색상 적용 산점도 그래프
qplot(displ, hwy, data=mpg, color=drv)
# displ과 hwy 변수와 관계를 drv로 구분
qplot(displ, hwy, data=mpg, color=drv, facets=.~drv)
View(mtcars)
str(mtcars) # 'data.frame':	32 obs. of  11 variables:
table(mtcars$carb)
table(mtcars$carb)
# 1  2  3  4  6  8
# 7 10  3 10  1  1
table(mtcars$cyl)
qplot(wt,mpg,data=mtcars)
qplot(wt,mpg,data=mtcars,color=factor(carb)) # 색상 적용
